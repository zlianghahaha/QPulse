# -*- coding: utf-8 -*-
"""Copy of DressedCRQuito5q-2qPulse-Expressibility&Entanglement.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10XxBi-ymwG19SNBEhYLIvJBZzRe4A-qn
"""

#from IPython.display import clear_output
#!pip install paddle-quantum
#!pip install qiskit
# !pip install qiskit-experiments
#clear_output()

# Commented out IPython magic to ensure Python compatibility.

import qiskit
import numpy as np
from qiskit.circuit.library import TwoLocal, RealAmplitudes
from qiskit import pulse, QuantumCircuit,circuit,transpile, providers
from qiskit.circuit import Gate
from qiskit.pulse import library, Schedule,GaussianSquare, ControlChannel, Play, Drag,DriveChannel,Delay,DriveChannel, SymbolicPulse, ShiftPhase
from qiskit.pulse import transforms
from qiskit.pulse.transforms import block_to_schedule,remove_directives
from qiskit.pulse import filters
from qiskit.pulse.filters import composite_filter, filter_instructions
from typing import List, Tuple, Iterable, Union, Dict, Callable, Set, Optional, Any
from qiskit.tools.visualization import circuit_drawer
from qiskit.visualization.pulse_v2 import draw, IQXSimple,IQXDebugging
from qiskit.compiler import assemble, schedule
from qiskit import IBMQ

from qiskit.providers.fake_provider.backends.athens.fake_athens import FakeAthens
import copy
import qiskit
# import multiset
from qiskit.circuit.parameterexpression import ParameterValueType
from qiskit.circuit import QuantumCircuit, Parameter
from qiskit import pulse, QuantumCircuit, IBMQ, visualization,execute, Aer
from qiskit.pulse import library
from qiskit.visualization.pulse_v2.stylesheet import IQXDebugging
from qiskit.visualization.pulse_v2 import draw
from qiskit.providers.fake_provider import FakeQuito, FakeBelem, FakeSantiago, FakeManila, FakeLagos, FakeLima,FakeJakarta, FakeAthens
from qiskit.pulse import transforms
from qiskit.pulse.transforms import block_to_schedule
from qiskit.pulse import filters
from qiskit.pulse.filters import composite_filter, filter_instructions
from typing import List, Tuple, Iterable, Union, Dict, Callable, Set, Optional, Any
from qiskit.pulse.instructions import Instruction
from qiskit.compiler import assemble, schedule
from qiskit.providers.aer.pulse import PulseSystemModel
from qiskit.providers.aer import PulseSimulator
from qiskit_dynamics import Solver, DynamicsBackend
from qiskit_dynamics.backend import default_experiment_result_function
from qiskit_dynamics.array import Array
import jax

backend = FakeQuito()

backend.configuration().hamiltonian['qub']

backend.configuration().hamiltonian['qub'] = {'0': 2,'1': 2,'2': 2,'3': 2,'4': 2 }
backend_model = PulseSystemModel.from_backend(backend)
backend_sim = PulseSimulator(system_model=backend_model)
backend_config = backend.configuration().to_dict()
num_qubits = int(backend_config['n_qubits'])
f = backend.properties().frequency
freq = [f(i) for i in range(num_qubits)]
jax.config.update("jax_enable_x64", True)
jax.config.update("jax_platform_name", "cpu")

Array.set_default_backend("jax")



"""# 1. Prepare Pulses

## 1.1 CR
"""

def generate_2q_pulsewithmeasure(backend, amp, angle):
  qubits = (0,1)
  backend_defaults = backend.defaults()
  inst_sched_map = backend_defaults.instruction_schedule_map 
  cr_pulse = inst_sched_map.get('cx', (0, 1)).filter(channels = [ControlChannel(0)], instruction_types=[Play]).instructions[0][1].pulse
  angle_parameter = angle
  duration_parameter = cr_pulse.parameters['duration']
  sigma_parameter = cr_pulse.parameters['sigma']
  width_parameter = cr_pulse.parameters['width']
  #declare pulse parameters and build GaussianSquare pulse
  cr_params = {}
  cr_params['duration'] = duration_parameter
  cr_params['amp'] = amp
  cr_params['angle'] = angle_parameter
  cr_params['sigma'] = sigma_parameter
  cr_params['width'] = width_parameter
  with pulse.build(backend) as pulse_x:
    pulse.play(GaussianSquare(**cr_params), ControlChannel(0))
    pulse.barrier(0)
    pulse.measure(qubits)

  return block_to_schedule(pulse_x)


"""## 1.2 Minimal basis CR+1q"""

def generate_2q_pulse(backend, amp, angle):
  backend_defaults = backend.defaults()
  inst_sched_map = backend_defaults.instruction_schedule_map 
  cr_pulse = inst_sched_map.get('cx', (0, 1)).filter(channels = [ControlChannel(0)], instruction_types=[Play]).instructions[0][1].pulse
  angle_parameter = angle
  duration_parameter = cr_pulse.parameters['duration']
  sigma_parameter = cr_pulse.parameters['sigma']
  width_parameter = cr_pulse.parameters['width']
  #declare pulse parameters and build GaussianSquare pulse
  cr_params = {}
  cr_params['duration'] = duration_parameter
  cr_params['amp'] = amp
  cr_params['angle'] = angle_parameter
  cr_params['sigma'] = sigma_parameter
  cr_params['width'] = width_parameter
  with pulse.build(backend) as pulse_x:
    pulse.play(GaussianSquare(**cr_params), ControlChannel(0))

  return block_to_schedule(pulse_x)

def generate_parametric_pulse1q(backend, q1, amp_list, angle_list):
  backend_defaults = backend.defaults()
  inst_sched_map = backend_defaults.instruction_schedule_map 
  x_pulse = inst_sched_map.get('x', (0)).filter(channels = [DriveChannel(0)], instruction_types=[Play]).instructions[0][1].pulse
  duration_parameter = x_pulse.parameters['duration']
  sigma_parameter = x_pulse.parameters['sigma']
  beta_parameter = x_pulse.parameters['beta']
  sched1 = pulse.Play(Drag(duration=duration_parameter, sigma=sigma_parameter, beta=beta_parameter, amp=amp_list, angle=angle_list), DriveChannel(0))
  with pulse.build(backend) as pulse_x:
    with pulse.transpiler_settings(initial_layout= [0]):
      sched = Schedule()
      pulse.call(sched)
  pulse_x.append(sched1)
  with pulse.build(backend) as pulse_y:
    with pulse.transpiler_settings(initial_layout= [0]): 
      pulse.call(pulse_x)
      pulse.barrier(q1)

  return  block_to_schedule(pulse_y)

def generate_12q_pulse(backend, oneqpulse, twoqpulse, qubits):
  oneqpulse+=(copy.deepcopy(twoqpulse))
  with pulse.build(backend) as pulse_x:
    with pulse.transpiler_settings(initial_layout= [0,1]):
      pulse.call(oneqpulse)
      pulse.barrier(0,1)
      pulse.measure(qubits)

  return block_to_schedule(pulse_x)


def generate_2q_pulse(backend, amp, angle):
  backend_defaults = backend.defaults()
  inst_sched_map = backend_defaults.instruction_schedule_map 
  cr_pulse = inst_sched_map.get('cx', (0, 1)).filter(channels = [ControlChannel(0)], instruction_types=[Play]).instructions[0][1].pulse
  angle_parameter = angle
  duration_parameter = cr_pulse.parameters['duration']
  sigma_parameter = cr_pulse.parameters['sigma']
  width_parameter = cr_pulse.parameters['width']
  #declare pulse parameters and build GaussianSquare pulse
  cr_params = {}
  cr_params['duration'] = duration_parameter
  cr_params['amp'] = amp
  cr_params['angle'] = angle_parameter
  cr_params['sigma'] = sigma_parameter
  cr_params['width'] = width_parameter
  with pulse.build(backend) as pulse_x:
    pulse.play(GaussianSquare(**cr_params), ControlChannel(0))
    pulse.barrier(0,1)

  return block_to_schedule(pulse_x)

def generate_parametric_pulse1q(backend, q1, amp_list, angle_list):
  sched1 = pulse.Play(Drag(duration=160, sigma=40, beta=0.4469017066717889, amp=amp_list, angle=angle_list), DriveChannel(0))
  with pulse.build(backend) as pulse_x:
    with pulse.transpiler_settings(initial_layout= [0]):
      sched = Schedule()
      pulse.call(sched)
  pulse_x.append(sched1)
  with pulse.build(backend) as pulse_y:
    with pulse.transpiler_settings(initial_layout= [0]): 
      pulse.call(pulse_x)

  return  block_to_schedule(pulse_y)

def generate_12q_pulse(backend, oneqpulse, twoqpulse, qubits):
  oneqpulse+=(copy.deepcopy(twoqpulse))
  with pulse.build(backend) as pulse_x:
    with pulse.transpiler_settings(initial_layout= [0,1]):
      pulse.call(oneqpulse)
      pulse.barrier(0,1)

  return block_to_schedule(pulse_x)

def generate_dressed_cr_pulse(backend, oneqpulse_left,oneqpulse_right, twopulse, qubits):
  qubits = (0,1)
  oneqpulse_left +=(copy.deepcopy(twoqpulse))
  oneqpulse_left += (copy.deepcopy(oneqpulse_right))
  with pulse.build(backend) as pulse_x:
    with pulse.transpiler_settings(initial_layout= [0,1]):
      pulse.call(oneqpulse_left)
      pulse.barrier(0,1)
      pulse.measure(qubits)

  return block_to_schedule(pulse_x)


def generate_2q_pulse(backend, amp, angle, width_time, qbit):
  width = 16*width_time
  backend_defaults = backend.defaults()
  inst_sched_map = backend_defaults.instruction_schedule_map 
  cr_pulse = inst_sched_map.get('cx', (0, 1)).filter(channels = [ControlChannel(0)], instruction_types=[Play]).instructions[0][1].pulse
  cr_params = {}
  cr_params['duration'] = cr_pulse.parameters['duration']
  cr_params['amp'] = cr_pulse.parameters['amp']
  cr_params['angle'] = cr_pulse.parameters['angle']
  cr_params['sigma'] = cr_pulse.parameters['sigma']
  cr_params['width'] = cr_pulse.parameters['width']
  cr_risefall = (cr_params['duration'] - cr_params['width']) / (2 * cr_params['sigma'])
  angle_parameter = angle
  duration_parameter =  int(width + 2 * cr_risefall * cr_params['sigma'])
  sigma_parameter = cr_pulse.parameters['sigma']
  width_parameter = width
  #declare pulse parameters and build GaussianSquare pulse
  #with pulse.build(backend) as pulse_x:
  with pulse.build(backend) as pulse_x:
    pulse.play(GaussianSquare(duration = duration_parameter, amp = amp, angle = angle_parameter, sigma = sigma_parameter, width=width_parameter), ControlChannel(qbit))
    pulse.play(GaussianSquare(duration = duration_parameter, amp = amp, angle = angle_parameter, sigma = sigma_parameter, width=width_parameter), DriveChannel(qbit))
    pulse.barrier(0,1)

  return block_to_schedule(pulse_x)


def generate_2qpulselayer(backend, qbit, amp, angle, width):
  with pulse.build(backend) as pulse_x:
    with pulse.transpiler_settings(initial_layout= [0,1]):
      sched = Schedule()
      pulse.call(sched)
  for qubit in range(qbit):
    pulse_twoq1, pulse_twoq2 = generate_2q_pulse(backend, amp[qubit], angle[qubit], width[qubit], qubit)
    pulse_x.append(pulse_twoq1)
    pulse_x.append(pulse_twoq2)
  with pulse.build(backend) as pulse_y:
    with pulse.transpiler_settings(initial_layout= [0,1]): 
      pulse.call(pulse_x)
      for qubit in range(qbit):
        pulse.barrier(qubit)
  return pulse_y


def generate_parametric_pulse1q(backend, q1, amp_list, angle_list):
  backend_defaults = backend.defaults()
  inst_sched_map = backend_defaults.instruction_schedule_map 
  x_pulse = inst_sched_map.get('x', (0)).filter(channels = [DriveChannel(0)], instruction_types=[Play]).instructions[0][1].pulse
  duration_parameter = x_pulse.parameters['duration']
  sigma_parameter = x_pulse.parameters['sigma']
  beta_parameter = x_pulse.parameters['beta']
  sched1 = pulse.Play(Drag(duration=duration_parameter, sigma=sigma_parameter, beta=beta_parameter, amp=amp_list, angle=angle_list), DriveChannel(q1))
  sched2 = pulse.Play(Drag(duration=duration_parameter, sigma=sigma_parameter, beta=beta_parameter, amp=amp_list, angle=angle_list), DriveChannel(q1+1))
  with pulse.build(backend) as pulse_x:
    with pulse.transpiler_settings(initial_layout= [0]):
      sched = Schedule()
      pulse.call(sched)
  pulse_x.append(sched1)
  pulse_x.append(sched2)
  with pulse.build(backend) as pulse_y:
    with pulse.transpiler_settings(initial_layout= [0]): 
      pulse.call(pulse_x)
      pulse.barrier(q1)
  return  block_to_schedule(pulse_y)

def generate_1qpulse_layer(backend, qbit, amp, angle):
  with pulse.build(backend) as pulse_x:
    with pulse.transpiler_settings(initial_layout= [0]):
      sched = Schedule()
      pulse.call(sched)
  for qubit in range(qbit):
    pulse_oneq = generate_parametric_pulse1q(backend, qubit, amp[qubit], angle[qubit])
    pulse_x.append(pulse_oneq)
  with pulse.build(backend) as pulse_y:
    with pulse.transpiler_settings(initial_layout= [0]): 
      pulse.call(pulse_x)
      for qubit in range(qbit):
        pulse.barrier(qubit)
  return pulse_y

def generate_12q1d1c_pulse(backend, oneqpulse, twoqpulse, qubits):
  oneqpulse+=(copy.deepcopy(twoqpulse))
  with pulse.build(backend) as pulse_x:
    with pulse.transpiler_settings(initial_layout= [0,1]):
      pulse.call(oneqpulse)
      pulse.barrier(0,1)
      pulse.measure(qubits)

  return block_to_schedule(pulse_x)



def generate_firstlayer(backend, num_qubits, amp, angle, width_time):
  with pulse.build(backend) as pulse_x:
    with pulse.transpiler_settings(initial_layout= [0]):
      sched = Schedule()
      pulse.call(sched)
  for qubit in range(num_qubits):
    pulse_oneq = generate_parametric_pulse1q(backend, qubit, amp[qubit], angle[qubit])
    pulse_x.append(pulse_oneq)
  with pulse.build(backend) as pulse_y:
    with pulse.transpiler_settings(initial_layout= [0]): 
      pulse.call(pulse_x)
      for qubit in range(num_qubits):
        pulse.barrier(qubit)
  for qubit in range(num_qubits):
    pulse_twoq1, pulse_twoq2 = generate_2q_pulse(backend, amp[qubit:][qubit], angle[qubit:][qubit], width_time[qubit],qubit)
    pulse_y.append(pulse_twoq1)
    pulse_y.append(pulse_twoq2)
  with pulse.build(backend) as pulse_z:
    with pulse.transpiler_settings(initial_layout= [0]): 
      pulse.call(pulse_y)
      for qubit in range(num_qubits):
        pulse.barrier(qubit)
  return pulse_z



"""## 1.3 dressed CR(under construction)"""

def generate_2q_pulse(backend, amp, angle, duration_time, qbit):
  duration = duration_time
  backend_defaults = backend.defaults()
  inst_sched_map = backend_defaults.instruction_schedule_map 
  cr_pulse = inst_sched_map.get('cx', (0, 1)).filter(channels = [ControlChannel(0)], instruction_types=[Play]).instructions[0][1].pulse
  cr_params = {}
  cr_params['duration'] = cr_pulse.parameters['duration']
  cr_params['amp'] = cr_pulse.parameters['amp']
  cr_params['angle'] = cr_pulse.parameters['angle']
  cr_params['sigma'] = cr_pulse.parameters['sigma']
  cr_params['width'] = cr_pulse.parameters['width']
  cr_risefall = (cr_params['duration'] - cr_params['width']) / (2 * cr_params['sigma'])
  angle_parameter = angle
  duration_parameter =  duration
  sigma_parameter = cr_pulse.parameters['sigma']
  width_parameter = int(duration_parameter - 2 * cr_risefall * cr_params['sigma'])
  #declare pulse parameters and build GaussianSquare pulse
  sched1 = pulse.Play(GaussianSquare(duration = duration_parameter, amp = amp, angle = angle_parameter, sigma = sigma_parameter, width=width_parameter), ControlChannel(qbit))

  with pulse.build(backend) as pulse_x:
    sched = Schedule()
  pulse_x.append(sched1)
  with pulse.build(backend) as pulse_y:
    pulse.call(pulse_x)
    pulse.barrier(qbit)
  #sched1= pulse.Play(GaussianSquare(duration = duration_parameter, amp = amp, angle = angle_parameter, sigma = sigma_parameter, width=width_parameter), DriveChannel(qbit))
  #pulse.barrier(0,1)

  return pulse_y

def generate_2qpulselayer(backend, qbit, amp, angle, width):
  with pulse.build(backend) as pulse_x:
    with pulse.transpiler_settings(initial_layout= [0,1]):
      sched = Schedule()
      pulse.call(sched)
  for qubit in range(qbit):
    pulse_twoq1 = generate_2q_pulse(backend, amp[qubit], angle[qubit], width[qubit], qubit)
    pulse_x.append(pulse_twoq1)
  with pulse.build(backend) as pulse_y:
    with pulse.transpiler_settings(initial_layout= [0,1]): 
      pulse.call(pulse_x)
      for qubit in range(qbit):
        pulse.barrier(qubit)
  return pulse_y

def generate_1q2pulse_layer(backend, qbit, amp, angle):
  with pulse.build(backend) as pulse_x:
    with pulse.transpiler_settings(initial_layout= [0]):
      sched = Schedule()
      pulse.call(sched)
  for qubit in range(qbit):
    pulse_oneq = generate_parametric_pulse1q(backend, qubit, amp[qubit], angle[qubit])
    pulse_x.append(pulse_oneq)
  with pulse.build(backend) as pulse_y:
    with pulse.transpiler_settings(initial_layout= [0]): 
      pulse.call(pulse_x)
      for qubit in range(qbit):
        pulse.barrier(qubit)
  return pulse_y

def generate_parametric_pulse1q(backend, qbit, amp_list, angle_list):
  backend_defaults = backend.defaults()
  inst_sched_map = backend_defaults.instruction_schedule_map 
  x_pulse = inst_sched_map.get('x', (0)).filter(channels = [DriveChannel(0)], instruction_types=[Play]).instructions[0][1].pulse
  duration_parameter = x_pulse.parameters['duration']
  sigma_parameter = x_pulse.parameters['sigma']
  beta_parameter = x_pulse.parameters['beta']
  # with pulse.build(backend) as pulse_x:
  #   with pulse.transpiler_settings(initial_layout= [0]):
  #     sched = Schedule()
  #     pulse.call(sched)
  sched1 = pulse.Play(Drag(duration=duration_parameter, sigma=sigma_parameter, beta=beta_parameter, amp=amp_list, angle=angle_list), DriveChannel(qbit))
  # pulse_x.append(sched1)
  # with pulse.build(backend) as pulse_y:
  #   with pulse.transpiler_settings(initial_layout= [0]): 
  #     pulse.call(pulse_x)

  return  sched1

def generate_secondlayer(backend, num_qubits, amp, angle, width_time):
  with pulse.build(backend) as pulse_x:
    with pulse.transpiler_settings(initial_layout= [0]):
      sched = Schedule()
      pulse.call(sched)
  for qubit in range(num_qubits):
    pulse_oneq = generate_parametric_pulse1q(backend, qubit, amp[qubit], angle[qubit])
    pulse_x.append(pulse_oneq)
  with pulse.build(backend) as pulse_y:
    with pulse.transpiler_settings(initial_layout= [0]): 
      pulse.call(pulse_x)
      for qubit in range(num_qubits):
        pulse.barrier(qubit)
  pulse_twoq1 = generate_2q_pulse(backend, amp[num_qubits:num_qubits+1][num_qubits-2], angle[num_qubits:num_qubits+1][num_qubits-2],width_time[num_qubits-2], num_qubits-1)
  pulse_y+=pulse_twoq1
  with pulse.build(backend) as pulse_y1:
    with pulse.transpiler_settings(initial_layout= [0]): 
      pulse.call(pulse_y)
      for qubit in range(num_qubits):
        pulse.barrier(qubit)
  for qubit in range(num_qubits):
    pulse_oneq = generate_parametric_pulse1q(backend, qubit, amp[num_qubits+1:][qubit], angle[num_qubits+1:][qubit])
    pulse_y1.append(pulse_oneq)
  with pulse.build(backend) as pulse_z:
    with pulse.transpiler_settings(initial_layout= [0]): 
      pulse.call(pulse_y1)
      for qubit in range(num_qubits):
        pulse.barrier(qubit)
        pulse.measure(qubit)
  return pulse_z
def generate_secondlayer(backend, num_qubits, amp, angle, width_time):
  with pulse.build(backend) as pulse_x:
    with pulse.transpiler_settings(initial_layout= [0]):
      sched = Schedule()
      pulse.call(sched)
  for qubit in range(num_qubits):
    pulse_oneq = generate_parametric_pulse1q(backend, qubit, amp[qubit], angle[qubit])
    pulse_x.append(pulse_oneq)
  with pulse.build(backend) as pulse_y:
    with pulse.transpiler_settings(initial_layout= [0]): 
      pulse.call(pulse_x)
      for qubit in range(num_qubits):
        pulse.barrier(qubit)
  pulse_twoq1 = generate_2q_pulse(backend, amp[num_qubits:num_qubits+1][num_qubits-2], angle[num_qubits:num_qubits+1][num_qubits-2],width_time[num_qubits-2], num_qubits-1)
  pulse_y+=pulse_twoq1
  with pulse.build(backend) as pulse_y1:
    with pulse.transpiler_settings(initial_layout= [0]): 
      pulse.call(pulse_y)
      for qubit in range(num_qubits):
        pulse.barrier(qubit)
  for qubit in range(num_qubits):
    pulse_oneq = generate_parametric_pulse1q(backend, qubit, amp[num_qubits+1:3*num_qubits-1][qubit], angle[num_qubits+1:3*num_qubits-1][qubit])
    pulse_y1.append(pulse_oneq)
  with pulse.build(backend) as pulse_y2:
    with pulse.transpiler_settings(initial_layout= [0]): 
      pulse.call(pulse_y1)
      for qubit in range(num_qubits):
        pulse.barrier(qubit)
  pulse_twoq2 = generate_2q_pulse(backend, amp[3*num_qubits-1], angle[3*num_qubits-1],width_time[num_qubits-1], num_qubits-1)
  pulse_y2+=pulse_twoq2
  with pulse.build(backend) as pulse_z:
    with pulse.transpiler_settings(initial_layout= [0]): 
      pulse.call(pulse_y2)
      for qubit in range(num_qubits):
        pulse.barrier(qubit)
        pulse.measure(qubit)
  return pulse_z
def generate_thirdlayer(backend, num_qubits, amp, angle, width_time):
  with pulse.build(backend) as pulse_x:
    with pulse.transpiler_settings(initial_layout= [0]):
      sched = Schedule()
      pulse.call(sched)
  for qubit in range(num_qubits):
    pulse_oneq = generate_parametric_pulse1q(backend, qubit, amp[qubit], angle[qubit])
    pulse_x.append(pulse_oneq)
  with pulse.build(backend) as pulse_y:
    with pulse.transpiler_settings(initial_layout= [0]): 
      pulse.call(pulse_x)
      for qubit in range(num_qubits):
        pulse.barrier(qubit)
  pulse_twoq1 = generate_2q_pulse(backend, amp[num_qubits], angle[num_qubits],width_time[0], 0)
  pulse_y+=pulse_twoq1
  with pulse.build(backend) as pulse_y1:
    with pulse.transpiler_settings(initial_layout= [0]): 
      pulse.call(pulse_y)
      for qubit in range(num_qubits):
        pulse.barrier(qubit)
  pulse_twoq2 = generate_2q_pulse(backend, amp[num_qubits+1], angle[num_qubits+1],width_time[1], 1)
  pulse_y1+=pulse_twoq2
  with pulse.build(backend) as pulse_y2:
    with pulse.transpiler_settings(initial_layout= [0]): 
      pulse.call(pulse_y1)
      for qubit in range(num_qubits):
        pulse.barrier(qubit)
  pulse_twoq3 = generate_2q_pulse(backend, amp[num_qubits+2], angle[num_qubits+2],width_time[2], 2)
  pulse_y2.append(copy.deepcopy(pulse_twoq3))
  with pulse.build(backend) as pulse_y3:
    with pulse.transpiler_settings(initial_layout= [0]): 
      pulse.call(pulse_y2)
      for qubit in range(num_qubits):
        pulse.barrier(qubit)
  pulse_twoq4 = generate_2q_pulse(backend, amp[num_qubits+3], angle[num_qubits+3],width_time[3], 3)
  pulse_y3+=pulse_twoq4
  with pulse.build(backend) as pulse_z:
    with pulse.transpiler_settings(initial_layout= [0]): 
      pulse.call(pulse_y3)
      for qubit in range(num_qubits):
        pulse.barrier(qubit)
  with pulse.build(backend) as pulse_z1:
    qubits = (0,1,2,3,4)
    pulse.call(pulse_z)
    pulse.barrier(0,1,2,3,4)
    pulse.measure(qubits)
  return pulse_z1

def p_F_qnnpulse(n, s, g, b=50, draw=False):
    f_list = list()
    rho_sample = outputs_universal2q
    title_str = "Universal 2q circuit"
    if g == 2:
        rho_sample = outputs_mix
        title_str = "1d1c CR"
    elif g == 3:
        rho_sample = outputs_rxcx
        title_str = "Rx-CX"
    elif g == 4:
        rho_sample = outputs_zzry
        title_str = "ZZ-Ry"
    elif g == 5:
        rho_sample = outputs_duration
        title_str = "Duration"
    # elif g == 6:
    #     rho_sample = outputs_amp
    #     title_str = "Parametrized Pulse Amplitude"
    # elif g == 7:
    #     rho_sample = outputs_angle
    #     title_str = "Parametrized Pulse Angle"
    # elif g == 8:
    #     rho_sample = outputs_mix
    #     title_str = "Parametrized Pulse General"

    # use previously collected data to compute fidelity
    for index in range(int(s / 2)):
        rho1 = rho_sample[index]
        rho2 = rho_sample[index+int(num_sample / 2)]
        f_list.append(state_fidelity(rho1, rho2)**2)
    f_list = np.array(f_list)
    
    # plot histgram
    if draw:
        plot_hist(f_list, b, title_str)
    distribution, _ = np.histogram(f_list, bins=np.linspace(0, 1, num=b), density=True)
    return distribution

def p_F_qnn(n, s, g, b=50, draw=False):
    f_list = list()
    rho_sample = outputs_universal2q
    title_str = "Universal 2q circuit"
    if g == 2:
        rho_sample = outputs_mix
        title_str = "1d1c CR"
    elif g == 3:
        rho_sample = outputs_rxcx
        title_str = "Rx-CX"
    elif g == 4:
        rho_sample = outputs_zzry
        title_str = "ZZ-Ry"
    elif g == 5:
        rho_sample = outputs_duration
        title_str = "Duration"
    # elif g == 6:
    #     rho_sample = outputs_amp
    #     title_str = "Parametrized Pulse Amplitude"
    # elif g == 7:
    #     rho_sample = outputs_angle
    #     title_str = "Parametrized Pulse Angle"
    # elif g == 8:
    #     rho_sample = outputs_mix
    #     title_str = "Parametrized Pulse General"

    # use previously collected data to compute fidelity
    for index in range(int(s / 2)):
        rho1 = rho_sample[index]
        rho2 = rho_sample[index+int(num_sample / 2)]
        f_list.append(state_fidelity(rho1, rho2)**2)
    f_list = np.array(f_list)
  
      # plot histgram
    if draw:
        plot_hist(f_list, b, title_str)
    distribution, _ = np.histogram(f_list, bins=np.linspace(0, 1, num=b), density=True)
    return distribution

  # plot histgram
def plot_hist(data, num_bin, title_str):
    def to_percent(y, position):
        return str(np.around(y*100, decimals=2)) + '%'
    plt.hist(data, weights=[1./len(data)]*len(data), bins=np.linspace(0, 1, num=num_bin), facecolor="blue", edgecolor="black", alpha=0.7)
    plt.xlabel("Fidelity")
    plt.ylabel("frequency")
    plt.title(title_str)
    formatter = FuncFormatter(to_percent)
    plt.gca().yaxis.set_major_formatter(formatter)
    plt.show()
    
    
# evaluate the probability distribution of F generated by a Haar random unitary
def p_F_haar(n, s, b=50, draw=False):
    f_list = list()
    # sampling
    for i in range(s):
        # sample a unitary
        u1 = haar_unitary(n)
        # the output of u1
        phi1 = u1[:,0]
        rho1 = to_state(np.outer(phi1, phi1.conj()))
        # sample a unitary
        u2 = haar_unitary(n)
        phi2 = u2[:,0]
        # the output of u2
        rho2 = to_state(np.outer(phi2, phi2.conj()))
        # compute fidality
        f_list.append(state_fidelity(rho1.numpy(), rho2.numpy())**2)

    f_list = np.array(f_list)

    # plot histgram
    if draw:
        title_str = "haar, %d qubit(s)" % num_qubit
        plot_hist(f_list, b, title_str)
    sample_distribution, _ = np.histogram(f_list, bins=np.linspace(0, 1, num=b), density=True)

    # compute a theoretical distribution
    theory_distribution = np.zeros_like(sample_distribution)
    for index in range(len(theory_distribution)):
        def p_continues(f):
            return (2 ** n - 1) * (1 - f) ** (2 ** n - 2)
        lower = 1/b*index
        upper = lower + 1/b
        theory_distribution[index], _ = integrate.quad(p_continues,lower,upper)
    return sample_distribution, theory_distribution   
      
"""# 2. Sampling

## 2.1 Test
"""
def drag_pulse(backend, amp, angle):
  backend_defaults = backend.defaults()
  inst_sched_map = backend_defaults.instruction_schedule_map 
  x_pulse = inst_sched_map.get('x', (0)).filter(channels = [DriveChannel(0)], instruction_types=[Play]).instructions[0][1].pulse
  duration_parameter = x_pulse.parameters['duration']
  sigma_parameter = x_pulse.parameters['sigma']
  beta_parameter = x_pulse.parameters['beta']
  pulse1 = Drag(duration=duration_parameter, sigma=sigma_parameter, beta=beta_parameter, amp=amp, angle=angle)
  return pulse1

def cr_pulse(backend, amp, angle, duration):
  backend_defaults = backend.defaults()
  inst_sched_map = backend_defaults.instruction_schedule_map 
  cr_pulse = inst_sched_map.get('cx', (0, 1)).filter(channels = [ControlChannel(0)], instruction_types=[Play]).instructions[0][1].pulse
  cr_params = {}
  cr_params['duration'] = cr_pulse.parameters['duration']
  cr_params['amp'] = cr_pulse.parameters['amp']
  cr_params['angle'] = cr_pulse.parameters['angle']
  cr_params['sigma'] = cr_pulse.parameters['sigma']
  cr_params['width'] = cr_pulse.parameters['width']
  cr_risefall = (cr_params['duration'] - cr_params['width']) / (2 * cr_params['sigma'])
  angle_parameter = angle
  duration_parameter =  duration
  sigma_parameter = cr_pulse.parameters['sigma']
  width_parameter = int(duration_parameter - 2 * cr_risefall * cr_params['sigma'])
  #declare pulse parameters and build GaussianSquare pulse
  pulse1 = GaussianSquare(duration = duration_parameter, amp = amp, angle = angle_parameter, sigma = sigma_parameter, width=width_parameter)
  return pulse1

def block_pulse(backend, amp, angle, width):
    with pulse.build(backend) as my_program1:
      # layer 1
      sched_list = []
      with pulse.build(backend) as sched1:
          for i in range(2):
              pulse.play(drag_pulse(backend, amp[i], angle[i]), DriveChannel(i))
      sched_list.append(sched1)

      with pulse.build(backend) as sched2: #这里control channel可以根据目标改一下
          uchan = pulse.control_channels(0, 1)[0]
          pulse.play(cr_pulse(backend, amp[2], angle[2], width[0]), uchan)
      sched_list.append(sched2)
      
      with pulse.build(backend) as sched3:
          qubits = (0,1,3)
          for i in qubits:
              pulse.play(drag_pulse(backend, amp[3+i], angle[3+i]), DriveChannel(i))
      sched_list.append(sched3)

      with pulse.build(backend) as sched4:
          uchan = pulse.control_channels(1, 2)[0]
          pulse.play(cr_pulse(backend, amp[6], angle[6], width[1]), uchan)
      sched_list.append(sched4)

      with pulse.build(backend) as sched5:
          qubits = (0,1,3)
          for i in qubits:
              pulse.play(drag_pulse(backend, amp[7+i], angle[7+i]), DriveChannel(i+1))
      sched_list.append(sched5)

      with pulse.build(backend) as sched6:
          uchan = pulse.control_channels(3,4)[0]
          pulse.play(cr_pulse(backend, amp[10], angle[10], width[2]), uchan)
      sched_list.append(sched6)

      with pulse.build(backend) as sched7:
          qubits = (1,2)
          for i in qubits:
              pulse.play(drag_pulse(backend, amp[11+i], angle[11+i]), DriveChannel(i+2))
      sched_list.append(sched7)
    
      with pulse.build(backend) as my_program:
        with pulse.transpiler_settings(initial_layout= [0,1,3,4]):
          with pulse.align_sequential():
              for sched in sched_list:
                  pulse.call(sched)
              pulse.measure_all()

    return my_program

def cr_pulsefixedamp(backend, angle, duration):
  backend_defaults = backend.defaults()
  inst_sched_map = backend_defaults.instruction_schedule_map 
  cr_pulse = inst_sched_map.get('cx', (0, 1)).filter(channels = [ControlChannel(0)], instruction_types=[Play]).instructions[0][1].pulse
  cr_params = {}
  cr_params['duration'] = cr_pulse.parameters['duration']
  amp_parameter = cr_pulse.parameters['amp']
  cr_params['angle'] = cr_pulse.parameters['angle']
  cr_params['sigma'] = cr_pulse.parameters['sigma']
  cr_params['width'] = cr_pulse.parameters['width']
  cr_risefall = (cr_params['duration'] - cr_params['width']) / (2 * cr_params['sigma'])
  angle_parameter = angle
  duration_parameter =  duration
  sigma_parameter = cr_pulse.parameters['sigma']
  width_parameter = int(duration_parameter - 2 * cr_risefall * cr_params['sigma'])
  #declare pulse parameters and build GaussianSquare pulse
  pulse1 = GaussianSquare(duration = duration_parameter, amp = amp_parameter, angle = angle_parameter, sigma = sigma_parameter, width=width_parameter)
  return pulse1
def block_pulse2q(backend, amp, angle, width):
    with pulse.build(backend) as my_program1:
      # layer 1
      sched_list = []
      with pulse.build(backend) as sched1:
          for i in range(2):
              pulse.play(drag_pulse(backend, amp[i], angle[i]), DriveChannel(i))
      sched_list.append(sched1)

      with pulse.build(backend) as sched2: #这里control channel可以根据目标改一下
          uchan = pulse.control_channels(0, 1)[0]
          pulse.play(cr_pulse(backend, amp[2], angle[2], width[0]), uchan)
      sched_list.append(sched2)
      
      with pulse.build(backend) as sched3:
          qubits = (0,1)
          for i in qubits:
              pulse.play(drag_pulse(backend, amp[3+i], angle[3+i]), DriveChannel(i))
      sched_list.append(sched3)

      with pulse.build(backend) as sched4:
          uchan = pulse.control_channels(0, 1)[0]
          pulse.play(cr_pulse(backend, amp[5], angle[5], width[1]), uchan)
      sched_list.append(sched4)

      with pulse.build(backend) as sched5:
          qubits = (0,1)
          for i in qubits:
              pulse.play(drag_pulse(backend, amp[6+i], angle[6+i]), DriveChannel(i))
      sched_list.append(sched5)

      with pulse.build(backend) as my_program:
        with pulse.transpiler_settings(initial_layout= [0,1]):
          with pulse.align_sequential():
              for sched in sched_list:
                  pulse.call(sched)
              pulse.measure(qubits)

    return my_program

def block_pulse2qfixedamp(backend, amp, angle, width):
    with pulse.build(backend) as my_program1:
      # layer 1
      sched_list = []
      with pulse.build(backend) as sched1:
          for i in range(2):
              pulse.play(drag_pulse(backend, amp[i], angle[i]), DriveChannel(i))
      sched_list.append(sched1)

      with pulse.build(backend) as sched2: #这里control channel可以根据目标改一下
          uchan = pulse.control_channels(0, 1)[0]
          pulse.play(cr_pulsefixedamp(backend, angle[2], width[0]), uchan)
      sched_list.append(sched2)
      
      with pulse.build(backend) as sched3:
          qubits = (0,1)
          for i in qubits:
              pulse.play(drag_pulse(backend, amp[1+i], angle[2+i]), DriveChannel(i))
      sched_list.append(sched3)

      with pulse.build(backend) as sched4:
          uchan = pulse.control_channels(0, 1)[0]
          pulse.play(cr_pulsefixedamp(backend, angle[5], width[1]), uchan)
      sched_list.append(sched4)

      with pulse.build(backend) as sched5:
          qubits = (0,1)
          for i in qubits:
              pulse.play(drag_pulse(backend, amp[3+i], angle[5+i]), DriveChannel(i))
      sched_list.append(sched5)

      with pulse.build(backend) as my_program:
        with pulse.transpiler_settings(initial_layout= [0,1]):
          with pulse.align_sequential():
              for sched in sched_list:
                  pulse.call(sched)
              pulse.measure(qubits)

    return my_program

def new_experiment_result_function(
    experiment_name,
    solver_result,
    measurement_subsystems,
    memory_slot_indices,
    num_memory_slots,
    backend,
    seed,
    metadata,
):
    result = default_experiment_result_function(
        experiment_name,
        solver_result,
        measurement_subsystems,
        memory_slot_indices,
        num_memory_slots,
        backend,
        seed,
        metadata,
    )
    
    result.statevector = solver_result.y[-1]
    return result
def block_dressedpulsbe2qfixedamp(backend, amp, angle, width):
    with pulse.build(backend) as my_program1:
      # layer 1
      sched_list = []
      with pulse.build(backend) as sched1:
          for i in range(2):
              pulse.play(drag_pulse(backend, amp[i], angle[i]), DriveChannel(i))
      sched_list.append(sched1)

      with pulse.build(backend) as sched2: #这里control channel可以根据目标改一下
          uchan = pulse.control_channels(0, 1)[0]
          pulse.play(cr_pulsefixedamp(backend, angle[2], width[0]), uchan)
      sched_list.append(sched2)
      
      with pulse.build(backend) as sched3:
          qubits = (0,1)
          for i in qubits:
              pulse.play(drag_pulse(backend, amp[1+i], angle[2+i]), DriveChannel(i))
      sched_list.append(sched3)

      with pulse.build(backend) as my_program:
        with pulse.transpiler_settings(initial_layout= [0,1]):
          with pulse.align_sequential():
              for sched in sched_list:
                  pulse.call(sched)
              pulse.measure(qubits)

    return my_program
def Decaylayer_pulse2q(backend, amp, angle, width):
    with pulse.build(backend) as my_program1:
      # layer 1
      sched_list = []
      with pulse.build(backend) as sched1:
          qubits = (0,1)
          for i in range(2):
              pulse.play(drag_pulse(backend, amp[i], angle[i]), DriveChannel(qubits[i]))
      sched_list.append(sched1)

      with pulse.build(backend) as sched2: #这里control channel可以根据目标改一下
          uchan = pulse.control_channels(0, 1)[0]
          pulse.play(cr_pulse(backend,amp[2], angle[2], width[0]), uchan)
      sched_list.append(sched2)
      

      with pulse.build(backend) as sched7:

          pulse.play(drag_pulse(backend, amp[3], angle[3]), DriveChannel(1))
      sched_list.append(sched7)
    

    
      with pulse.build(backend) as my_program:
        with pulse.transpiler_settings(initial_layout= [0,1]):
          with pulse.align_sequential():
              for sched in sched_list:
                  pulse.call(sched)
              qubits = (0,1)
              pulse.measure(qubits)

    return my_program
def Decaylayer_pulse2qfixedamp(backend, amp, angle, width):
    with pulse.build(backend) as my_program1:
      # layer 1
      sched_list = []
      with pulse.build(backend) as sched1:
          qubits = (0,1)
          for i in range(2):
              pulse.play(drag_pulse(backend, amp[i], angle[i]), DriveChannel(qubits[i]))
      sched_list.append(sched1)

      with pulse.build(backend) as sched2: #这里control channel可以根据目标改一下
          uchan = pulse.control_channels(0, 1)[0]
          pulse.play(cr_pulsefixedamp(backend, angle[2], width[0]), uchan)
      sched_list.append(sched2)
      

      with pulse.build(backend) as sched7:

          pulse.play(drag_pulse(backend, amp[2], angle[3]), DriveChannel(1))
      sched_list.append(sched7)
    

    
      with pulse.build(backend) as my_program:
        with pulse.transpiler_settings(initial_layout= [0,1]):
          with pulse.align_sequential():
              for sched in sched_list:
                  pulse.call(sched)
              qubits = (0,1)
              pulse.measure(qubits)

    return my_program
import paddle
import paddle_quantum as pq
from paddle_quantum.ansatz.circuit import Circuit
from paddle_quantum.qinfo import state_fidelity, partial_trace, purity
import warnings

import qiskit.quantum_info as qi


"""## 2.2 Scan amp"""

import random
import decimal
import numpy as np
import paddle
import paddle_quantum as pq
from paddle_quantum.ansatz.circuit import Circuit
from paddle_quantum.visual import plot_state_in_bloch_sphere
from paddle_quantum.linalg import haar_unitary
from paddle_quantum.qinfo import state_fidelity
from paddle_quantum.state.common import to_state
import matplotlib.pyplot as plt
from matplotlib.ticker import FuncFormatter
from scipy import integrate


if __name__ == '__main__':
  """Calculate Entanglement Capability"""
  backend_run = DynamicsBackend.from_backend(backend, evaluation_mode="sparse")
  solver_options = {"method": "jax_odeint", "atol": 1e-6, "rtol": 1e-8}

  backend_run.set_options(solver_options=solver_options,experiment_result_function=new_experiment_result_function)
  backend_run.configuration = lambda: backend.configuration()
  outputs_mix = list()   
  num_sample = 500
  ent_list = []
  amp_list = []
  ang_list = []
  duration_list = []
  for _ in range(num_sample):

    amp = [float(decimal.Decimal(random.randrange(0, 1000))/1000) for _ in range(3)]
    ang = [2*np.pi*float(decimal.Decimal(random.randrange(0, 1000))/1000) for _ in range(4)]
    duration = [random.randrange(256, 1024, 16) for _ in range(1)]
    # generate new parametrized pulse
    firstlayer = Decaylayer_pulse2qfixedamp(backend,amp, ang,duration)
    # set up pulse schedule
#    cirq_gates = assemble(firstlayer,
#                      backend=backend_sim,
#                      qubit_lo_freq=freq,
#                      meas_level=2,
#                      meas_return='avg',
#                      shots=2048)

    results = backend_run.run(firstlayer, meas_level = 2).result()
    # Returen the density matrix of q0
    vec = results.results[0].statevector
    # print(len(vec))
    rho1 = qi.partial_trace(vec, [1,2,3,4])
    rho2 = qi.partial_trace(vec, [0,2,3,4])

    #p = (rho1.purity() + rho2.purity() + rho3.purity() + rho4.purity())/4
#    p = (qi.purity(rho1) + qi.purity(rho2))/2
    p = (rho1.purity() + rho2.purity())/2
    # Calculate Q
    Q =2*(1-p)
    print(Q)
    ent_list.append(Q)
    ang_list.append(ang)
    amp_list.append(amp)
    duration_list.append(duration)

  import pickle
  file_open = open('Q.pickle','wb')
  pickle.dump(Q,file_open)
  file_open.close()

  Ent = sum(ent_list)/num_sample
  print("Eantangling Capability for this PQC is: {0:.6f}".format(Ent))

  file_open = open('2qDecaylayerfixedampentlist.pickle','wb')
  pickle.dump(ent_list,file_open)
  file_open.close()
  file_open = open('2qDecaylayerfixedampanglelist.pickle','wb')
  pickle.dump(ang_list,file_open)
  file_open.close()

  file_open = open('2qDecaylayerfixedampamplitudelist.pickle','wb')
  pickle.dump(amp_list,file_open)
  file_open.close()
  file_open = open('2qDecaylayerfixedampdurationlist.pickle','wb')
  pickle.dump(duration_list,file_open)
  file_open.close()
  """## 2.3 Scan angle"""