# -*- coding: utf-8 -*-
"""DressedCRQuito5q_2qPulse_Expressibility&Entanglement (1).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1nKeQLub-YmP5bxFn6AMAniOK_yDFHZmi
"""

import qiskit
import numpy as np
from qiskit.circuit.library import TwoLocal, RealAmplitudes
from qiskit import pulse, QuantumCircuit,circuit,transpile
from qiskit.circuit import Gate
from qiskit.pulse import library, Schedule,GaussianSquare, ControlChannel, Play, Drag,DriveChannel,Delay,DriveChannel, SymbolicPulse, ShiftPhase
from qiskit.pulse import transforms
from qiskit.pulse.transforms import block_to_schedule,remove_directives
from qiskit.pulse import filters
from qiskit.pulse.filters import composite_filter, filter_instructions
from typing import List, Tuple, Iterable, Union, Dict, Callable, Set, Optional, Any
from qiskit.tools.visualization import circuit_drawer
from qiskit.visualization.pulse_v2 import draw, IQXSimple,IQXDebugging
from qiskit.compiler import assemble, schedule
from qiskit import IBMQ

from qiskit.providers.fake_provider.backends.athens.fake_athens import FakeAthens
import copy
import qiskit
# import multiset
from qiskit.circuit.parameterexpression import ParameterValueType
from qiskit.circuit import QuantumCircuit, Parameter
from qiskit import pulse, QuantumCircuit, IBMQ, visualization,execute, Aer
from qiskit.pulse import library
from qiskit.visualization.pulse_v2.stylesheet import IQXDebugging
from qiskit.visualization.pulse_v2 import draw
from qiskit.providers.fake_provider import FakeQuito, FakeBelem, FakeSantiago, FakeManila, FakeLagos, FakeLima,FakeJakarta, FakeAthens
from qiskit.pulse import transforms
from qiskit.pulse.transforms import block_to_schedule
from qiskit.pulse import filters
from qiskit.pulse.filters import composite_filter, filter_instructions
from typing import List, Tuple, Iterable, Union, Dict, Callable, Set, Optional, Any
from qiskit.pulse.instructions import Instruction
from qiskit.compiler import assemble, schedule
from qiskit.providers.aer.pulse import PulseSystemModel
from qiskit.providers.aer import PulseSimulator
from qiskit_dynamics import Solver, DynamicsBackend
from qiskit_dynamics.backend import default_experiment_result_function
from qiskit_dynamics.array import Array
import jax

backend = FakeQuito()

backend.configuration().hamiltonian['qub']

backend.configuration().hamiltonian['qub'] = {'0': 2,'1': 2,'2': 2,'3': 2,'4': 2 }
backend_model = PulseSystemModel.from_backend(backend)
backend_sim = PulseSimulator(system_model=backend_model)
backend_config = backend.configuration().to_dict()
num_qubits = int(backend_config['n_qubits'])
f = backend.properties().frequency
freq = [f(i) for i in range(num_qubits)]
jax.config.update("jax_enable_x64", True)
jax.config.update("jax_platform_name", "cpu")

Array.set_default_backend("jax")


"""## 1.3 dressed CR(under construction)"""

def generate_2q_pulse(backend, amp, angle, duration_time, qbit):
  duration = duration_time
  backend_defaults = backend.defaults()
  inst_sched_map = backend_defaults.instruction_schedule_map 
  cr_pulse = inst_sched_map.get('cx', (0, 1)).filter(channels = [ControlChannel(0)], instruction_types=[Play]).instructions[0][1].pulse
  cr_params = {}
  cr_params['duration'] = cr_pulse.parameters['duration']
  cr_params['amp'] = cr_pulse.parameters['amp']
  cr_params['angle'] = cr_pulse.parameters['angle']
  cr_params['sigma'] = cr_pulse.parameters['sigma']
  cr_params['width'] = cr_pulse.parameters['width']
  cr_risefall = (cr_params['duration'] - cr_params['width']) / (2 * cr_params['sigma'])
  angle_parameter = angle
  duration_parameter =  duration
  sigma_parameter = cr_pulse.parameters['sigma']
  width_parameter = int(duration_parameter - 2 * cr_risefall * cr_params['sigma'])
  #declare pulse parameters and build GaussianSquare pulse
  sched1 = pulse.Play(GaussianSquare(duration = duration_parameter, amp = amp, angle = angle_parameter, sigma = sigma_parameter, width=width_parameter), ControlChannel(qbit))

  with pulse.build(backend) as pulse_x:
    sched = Schedule()
  pulse_x.append(sched1)
  with pulse.build(backend) as pulse_y:
    pulse.call(pulse_x)
    pulse.barrier(qbit)
  #sched1= pulse.Play(GaussianSquare(duration = duration_parameter, amp = amp, angle = angle_parameter, sigma = sigma_parameter, width=width_parameter), DriveChannel(qbit))
  #pulse.barrier(0,1)

  return pulse_y

def generate_2qpulselayer(backend, qbit, amp, angle, width):
  with pulse.build(backend) as pulse_x:
    with pulse.transpiler_settings(initial_layout= [0,1]):
      sched = Schedule()
      pulse.call(sched)
  for qubit in range(qbit):
    pulse_twoq1 = generate_2q_pulse(backend, amp[qubit], angle[qubit], width[qubit], qubit)
    pulse_x.append(pulse_twoq1)
  with pulse.build(backend) as pulse_y:
    with pulse.transpiler_settings(initial_layout= [0,1]): 
      pulse.call(pulse_x)
      for qubit in range(qbit):
        pulse.barrier(qubit)
  return pulse_y

def generate_1q2pulse_layer(backend, qbit, amp, angle):
  with pulse.build(backend) as pulse_x:
    with pulse.transpiler_settings(initial_layout= [0]):
      sched = Schedule()
      pulse.call(sched)
  for qubit in range(qbit):
    pulse_oneq = generate_parametric_pulse1q(backend, qubit, amp[qubit], angle[qubit])
    pulse_x.append(pulse_oneq)
  with pulse.build(backend) as pulse_y:
    with pulse.transpiler_settings(initial_layout= [0]): 
      pulse.call(pulse_x)
      for qubit in range(qbit):
        pulse.barrier(qubit)
  return pulse_y

def generate_parametric_pulse1q(backend, qbit, amp_list, angle_list):
  backend_defaults = backend.defaults()
  inst_sched_map = backend_defaults.instruction_schedule_map 
  x_pulse = inst_sched_map.get('x', (0)).filter(channels = [DriveChannel(0)], instruction_types=[Play]).instructions[0][1].pulse
  duration_parameter = x_pulse.parameters['duration']
  sigma_parameter = x_pulse.parameters['sigma']
  beta_parameter = x_pulse.parameters['beta']
  # with pulse.build(backend) as pulse_x:
  #   with pulse.transpiler_settings(initial_layout= [0]):
  #     sched = Schedule()
  #     pulse.call(sched)
  sched1 = pulse.Play(Drag(duration=duration_parameter, sigma=sigma_parameter, beta=beta_parameter, amp=amp_list, angle=angle_list), DriveChannel(qbit))
  # pulse_x.append(sched1)
  # with pulse.build(backend) as pulse_y:
  #   with pulse.transpiler_settings(initial_layout= [0]): 
  #     pulse.call(pulse_x)

  return  sched1

def generate_secondlayer(backend, num_qubits, amp, angle, width_time):
  with pulse.build(backend) as pulse_x:
    with pulse.transpiler_settings(initial_layout= [0]):
      sched = Schedule()
      pulse.call(sched)
  for qubit in range(num_qubits):
    pulse_oneq = generate_parametric_pulse1q(backend, qubit, amp[qubit], angle[qubit])
    pulse_x.append(pulse_oneq)
  with pulse.build(backend) as pulse_y:
    with pulse.transpiler_settings(initial_layout= [0]): 
      pulse.call(pulse_x)
      for qubit in range(num_qubits):
        pulse.barrier(qubit)
  pulse_twoq1 = generate_2q_pulse(backend, amp[num_qubits:num_qubits+1][num_qubits-2], angle[num_qubits:num_qubits+1][num_qubits-2],width_time[num_qubits-2], num_qubits-1)
  pulse_y+=pulse_twoq1
  with pulse.build(backend) as pulse_y1:
    with pulse.transpiler_settings(initial_layout= [0]): 
      pulse.call(pulse_y)
      for qubit in range(num_qubits):
        pulse.barrier(qubit)
  for qubit in range(num_qubits):
    pulse_oneq = generate_parametric_pulse1q(backend, qubit, amp[num_qubits+1:3*num_qubits-1][qubit], angle[num_qubits+1:3*num_qubits-1][qubit])
    pulse_y1.append(pulse_oneq)
  with pulse.build(backend) as pulse_y2:
    with pulse.transpiler_settings(initial_layout= [0]): 
      pulse.call(pulse_y1)
      for qubit in range(num_qubits):
        pulse.barrier(qubit)
  pulse_twoq2 = generate_2q_pulse(backend, amp[3*num_qubits-1], angle[3*num_qubits-1],width_time[num_qubits-1], num_qubits-1)
  pulse_y2+=pulse_twoq2
  with pulse.build(backend) as pulse_z:
    with pulse.transpiler_settings(initial_layout= [0]): 
      pulse.call(pulse_y2)
      for qubit in range(num_qubits):
        pulse.barrier(qubit)
        pulse.measure(qubit)
  return pulse_z
def generate_thirdlayer(backend, num_qubits, amp, angle, width_time):
  with pulse.build(backend) as pulse_x:
    with pulse.transpiler_settings(initial_layout= [0]):
      sched = Schedule()
      pulse.call(sched)
  for qubit in range(num_qubits):
    pulse_oneq = generate_parametric_pulse1q(backend, qubit, amp[qubit], angle[qubit])
    pulse_x.append(pulse_oneq)
  with pulse.build(backend) as pulse_y:
    with pulse.transpiler_settings(initial_layout= [0]): 
      pulse.call(pulse_x)
      for qubit in range(num_qubits):
        pulse.barrier(qubit)
  pulse_twoq1 = generate_2q_pulse(backend, amp[num_qubits], angle[num_qubits],width_time[0], 0)
  pulse_y+=pulse_twoq1
  with pulse.build(backend) as pulse_y1:
    with pulse.transpiler_settings(initial_layout= [0]): 
      pulse.call(pulse_y)
      for qubit in range(num_qubits):
        pulse.barrier(qubit)
  pulse_twoq2 = generate_2q_pulse(backend, amp[num_qubits+1], angle[num_qubits+1],width_time[1], 1)
  pulse_y1+=pulse_twoq2
  with pulse.build(backend) as pulse_y2:
    with pulse.transpiler_settings(initial_layout= [0]): 
      pulse.call(pulse_y1)
      for qubit in range(num_qubits):
        pulse.barrier(qubit)
  pulse_twoq3 = generate_2q_pulse(backend, amp[num_qubits+2], angle[num_qubits+2],width_time[2], 2)
  pulse_y2.append(copy.deepcopy(pulse_twoq3))
  with pulse.build(backend) as pulse_y3:
    with pulse.transpiler_settings(initial_layout= [0]): 
      pulse.call(pulse_y2)
      for qubit in range(num_qubits):
        pulse.barrier(qubit)
  pulse_twoq4 = generate_2q_pulse(backend, amp[num_qubits+3], angle[num_qubits+3],width_time[3], 3)
  pulse_y3+=pulse_twoq4
  with pulse.build(backend) as pulse_z:
    with pulse.transpiler_settings(initial_layout= [0]): 
      pulse.call(pulse_y3)
      for qubit in range(num_qubits):
        pulse.barrier(qubit)
  with pulse.build(backend) as pulse_z1:
    qubits = (0,1,2,3,4)
    pulse.call(pulse_z)
    pulse.barrier(0,1,2,3,4)
    pulse.measure(qubits)
  return pulse_z1

def new_experiment_result_function(
    experiment_name,
    solver_result,
    measurement_subsystems,
    memory_slot_indices,
    num_memory_slots,
    backend,
    seed,
    metadata,
):
    result = default_experiment_result_function(
        experiment_name,
        solver_result,
        measurement_subsystems,
        memory_slot_indices,
        num_memory_slots,
        backend,
        seed,
        metadata,
    )
    
    result.statevector = solver_result.y[-1]
    return result
def drag_pulse(backend, amp, angle):
  backend_defaults = backend.defaults()
  inst_sched_map = backend_defaults.instruction_schedule_map 
  x_pulse = inst_sched_map.get('x', (0)).filter(channels = [DriveChannel(0)], instruction_types=[Play]).instructions[0][1].pulse
  duration_parameter = x_pulse.parameters['duration']
  sigma_parameter = x_pulse.parameters['sigma']
  beta_parameter = x_pulse.parameters['beta']
  pulse1 = Drag(duration=duration_parameter, sigma=sigma_parameter, beta=beta_parameter, amp=amp, angle=angle)
  return pulse1

def cr_pulse(backend, amp, angle, duration):
  backend_defaults = backend.defaults()
  inst_sched_map = backend_defaults.instruction_schedule_map 
  cr_pulse = inst_sched_map.get('cx', (0, 1)).filter(channels = [ControlChannel(0)], instruction_types=[Play]).instructions[0][1].pulse
  cr_params = {}
  cr_params['duration'] = cr_pulse.parameters['duration']
  cr_params['amp'] = cr_pulse.parameters['amp']
  cr_params['angle'] = cr_pulse.parameters['angle']
  cr_params['sigma'] = cr_pulse.parameters['sigma']
  cr_params['width'] = cr_pulse.parameters['width']
  cr_risefall = (cr_params['duration'] - cr_params['width']) / (2 * cr_params['sigma'])
  angle_parameter = angle
  duration_parameter =  duration
  sigma_parameter = cr_pulse.parameters['sigma']
  width_parameter = int(duration_parameter - 2 * cr_risefall * cr_params['sigma'])
  #declare pulse parameters and build GaussianSquare pulse
  pulse1 = GaussianSquare(duration = duration_parameter, amp = amp, angle = angle_parameter, sigma = sigma_parameter, width=width_parameter)
  return pulse1
def block_pulse(backend, amp, angle, width):
    with pulse.build(backend) as my_program1:
      # layer 1
      sched_list = []
      with pulse.build(backend) as sched1:
          for i in range(2):
              pulse.play(drag_pulse(backend, amp[i], angle[i]), DriveChannel(i))
      sched_list.append(sched1)

      with pulse.build(backend) as sched2: #这里control channel可以根据目标改一下
          uchan = pulse.control_channels(0, 1)[0]
          pulse.play(cr_pulse(backend, amp[2], angle[2], width[0]), uchan)
      sched_list.append(sched2)
      
      with pulse.build(backend) as sched3:
          qubits = (0,1,3,4)
          for i in range(3):
              pulse.play(drag_pulse(backend, amp[3+i], angle[3+i]), DriveChannel(qubits[i]))
      sched_list.append(sched3)

      with pulse.build(backend) as sched4:
          uchan = pulse.control_channels(1, 2)[0]
          pulse.play(cr_pulse(backend, amp[6], angle[6], width[1]), uchan)
      sched_list.append(sched4)

      with pulse.build(backend) as sched5:
          qubits = (0,1,3,4)
          for i in range(3):
              pulse.play(drag_pulse(backend, amp[7+i], angle[7+i]), DriveChannel(qubits[i]))
      sched_list.append(sched5)

      with pulse.build(backend) as sched6:
          uchan = pulse.control_channels(3,4)[0]
          pulse.play(cr_pulse(backend, amp[10], angle[10], width[2]), uchan)
      sched_list.append(sched6)

      with pulse.build(backend) as sched7:
          qubits = (3,4)
          for i in range(2):
              pulse.play(drag_pulse(backend, amp[11+i], angle[11+i]), DriveChannel(qubits[i]))
      sched_list.append(sched7)
    
      with pulse.build(backend) as my_program:
        with pulse.transpiler_settings(initial_layout= [0,1,3,4]):
          with pulse.align_sequential():
              for sched in sched_list:
                  pulse.call(sched)
              qubits = (0,1,3,4)
              pulse.measure(qubits)

    return my_program

def block_pulsenogateknowledge(backend, amp, angle, width):
    with pulse.build(backend) as my_program1:
      # layer 1
      sched_list = []
      with pulse.build(backend) as sched1:
          qubits = (0,1,3,4)
          for i in qubits:
              pulse.play(drag_pulse(backend, amp[i], angle[i]), DriveChannel(i))
      sched_list.append(sched1)

      with pulse.build(backend) as sched2: #这里control channel可以根据目标改一下
          uchan = pulse.control_channels(0, 1)[0]
          pulse.play(cr_pulse(backend, amp[4], angle[4], width[0]), uchan)
      sched_list.append(sched2)

      with pulse.build(backend) as sched4:
          uchan = pulse.control_channels(1, 2)[0]
          pulse.play(cr_pulse(backend, amp[5], angle[5], width[1]), uchan)
      sched_list.append(sched4)

      with pulse.build(backend) as sched6:
          uchan = pulse.control_channels(3,4)[0]
          pulse.play(cr_pulse(backend, amp[6], angle[6], width[2]), uchan)
      sched_list.append(sched6)


      with pulse.build(backend) as my_program:
        with pulse.transpiler_settings(initial_layout= [0,1,3,4]):
          with pulse.align_sequential():
              for sched in sched_list:
                  pulse.call(sched)
              pulse.measure_all()

    return my_program
def block_pulse2q(backend, amp, angle, width):
    with pulse.build(backend) as my_program1:
      # layer 1
      sched_list = []
      with pulse.build(backend) as sched1:
          for i in range(2):
              pulse.play(drag_pulse(backend, amp[i], angle[i]), DriveChannel(i))
      sched_list.append(sched1)

      with pulse.build(backend) as sched2: #这里control channel可以根据目标改一下
          uchan = pulse.control_channels(0, 1)[0]
          pulse.play(cr_pulse(backend, amp[2], angle[2], width[0]), uchan)
      sched_list.append(sched2)
      
      with pulse.build(backend) as sched3:
          qubits = (0,1)
          for i in qubits:
              pulse.play(drag_pulse(backend, amp[2+i], angle[2+i]), DriveChannel(i))
      sched_list.append(sched3)

      with pulse.build(backend) as sched4:
          uchan = pulse.control_channels(1, 2)[0]
          pulse.play(cr_pulse(backend, amp[5], angle[5], width[1]), uchan)
      sched_list.append(sched4)

      with pulse.build(backend) as sched5:
          qubits = (0,1)
          for i in qubits:
              pulse.play(drag_pulse(backend, amp[5+i], angle[5+i]), DriveChannel(i))
      sched_list.append(sched5)

      with pulse.build(backend) as my_program:
        with pulse.transpiler_settings(initial_layout= [0,1]):
          with pulse.align_sequential():
              for sched in sched_list:
                  pulse.call(sched)
              pulse.measure(qubits)

    return my_program
def cr_pulsefixedamp(backend, angle, duration):
  backend_defaults = backend.defaults()
  inst_sched_map = backend_defaults.instruction_schedule_map 
  cr_pulse = inst_sched_map.get('cx', (0, 1)).filter(channels = [ControlChannel(0)], instruction_types=[Play]).instructions[0][1].pulse
  cr_params = {}
  cr_params['duration'] = cr_pulse.parameters['duration']
  amp_parameter = cr_pulse.parameters['amp']
  cr_params['angle'] = cr_pulse.parameters['angle']
  cr_params['sigma'] = cr_pulse.parameters['sigma']
  cr_params['width'] = cr_pulse.parameters['width']
  cr_risefall = (cr_params['duration'] - cr_params['width']) / (2 * cr_params['sigma'])
  angle_parameter = angle
  duration_parameter =  duration
  sigma_parameter = cr_pulse.parameters['sigma']
  width_parameter = int(duration_parameter - 2 * cr_risefall * cr_params['sigma'])
  #declare pulse parameters and build GaussianSquare pulse
  pulse1 = GaussianSquare(duration = duration_parameter, amp = amp_parameter, angle = angle_parameter, sigma = sigma_parameter, width=width_parameter)
  return pulse1
def block_pulsefixedamp(backend, amp, angle, width):
    with pulse.build(backend) as my_program1:
      # layer 1
      sched_list = []
      with pulse.build(backend) as sched1:
          for i in range(2):
              pulse.play(drag_pulse(backend, amp[i], angle[i]), DriveChannel(i))
      sched_list.append(sched1)

      with pulse.build(backend) as sched2: #这里control channel可以根据目标改一下
          uchan = pulse.control_channels(0, 1)[0]
          pulse.play(cr_pulsefixedamp(backend, angle[2], width[0]), uchan)
      sched_list.append(sched2)
      
      with pulse.build(backend) as sched3:
          qubits = (0,1,3)
          for i in range(3):
              pulse.play(drag_pulse(backend, amp[2+i], angle[3+i]), DriveChannel(qubits[i]))
      sched_list.append(sched3)

      with pulse.build(backend) as sched4:
          uchan = pulse.control_channels(1, 3)[0]
          pulse.play(cr_pulsefixedamp(backend, angle[6], width[1]), uchan)
      sched_list.append(sched4)

      with pulse.build(backend) as sched5:
          qubits = (1,3,4)
          for i in range(3):
              pulse.play(drag_pulse(backend, amp[5+i], angle[7+i]), DriveChannel(qubits[i]))
      sched_list.append(sched5)

      with pulse.build(backend) as sched6:
          uchan = pulse.control_channels(3,4)[0]
          pulse.play(cr_pulsefixedamp(backend, angle[10], width[2]), uchan)
      sched_list.append(sched6)

      with pulse.build(backend) as sched7:
          qubits = (3,4)
          for i in range(2):
              pulse.play(drag_pulse(backend, amp[8+i], angle[11+i]), DriveChannel(qubits[i]))
      sched_list.append(sched7)
    
      with pulse.build(backend) as my_program:
        with pulse.transpiler_settings(initial_layout= [0,1,3,4]):
          with pulse.align_sequential():
              for sched in sched_list:
                  pulse.call(sched)
              qubits = (0,1,3,4)
              pulse.measure(qubits)

    return my_program

def block_pulse2qfixedamp(backend, amp, angle, width):
    with pulse.build(backend) as my_program1:
      # layer 1
      sched_list = []
      with pulse.build(backend) as sched1:
          for i in range(2):
              pulse.play(drag_pulse(backend, amp[i], angle[i]), DriveChannel(i))
      sched_list.append(sched1)

      with pulse.build(backend) as sched2: #这里control channel可以根据目标改一下
          uchan = pulse.control_channels(0, 1)[0]
          pulse.play(cr_pulsefixedamp(backend, angle[2], width[0]), uchan)
      sched_list.append(sched2)
      
      with pulse.build(backend) as sched3:
          qubits = (0,1)
          for i in qubits:
              pulse.play(drag_pulse(backend, amp[1+i], angle[2+i]), DriveChannel(i))
      sched_list.append(sched3)

      with pulse.build(backend) as sched4:
          uchan = pulse.control_channels(1,3)[0]
          pulse.play(cr_pulsefixedamp(backend, angle[5], width[1]), uchan)
      sched_list.append(sched4)

      with pulse.build(backend) as sched5:
          qubits = (0,1)
          for i in qubits:
              pulse.play(drag_pulse(backend, amp[3+i], angle[5+i]), DriveChannel(i))
      sched_list.append(sched5)

      with pulse.build(backend) as my_program:
        with pulse.transpiler_settings(initial_layout= [0,1]):
          with pulse.align_sequential():
              for sched in sched_list:
                  pulse.call(sched)
              pulse.measure(qubits)

    return my_program
def block_dressedpulsbe2qfixedamp(backend, amp, angle, width):
    with pulse.build(backend) as my_program1:
      # layer 1
      sched_list = []
      with pulse.build(backend) as sched1:
          for i in range(2):
              pulse.play(drag_pulse(backend, amp[i], angle[i]), DriveChannel(i))
      sched_list.append(sched1)

      with pulse.build(backend) as sched2: #这里control channel可以根据目标改一下
          uchan = pulse.control_channels(0, 1)[0]
          pulse.play(cr_pulsefixedamp(backend, angle[2], width[0]), uchan)
      sched_list.append(sched2)
      
      with pulse.build(backend) as sched3:
          qubits = (0,1)
          for i in qubits:
              pulse.play(drag_pulse(backend, amp[1+i], angle[2+i]), DriveChannel(i))
      sched_list.append(sched3)

      with pulse.build(backend) as my_program:
        with pulse.transpiler_settings(initial_layout= [0,1]):
          with pulse.align_sequential():
              for sched in sched_list:
                  pulse.call(sched)
              pulse.measure(qubits)

    return my_program
"""# 2. Sampling

## 2.1 Test
"""

import random 
import decimal
import qiskit.quantum_info as qi
import paddle
import paddle_quantum as pq
from paddle_quantum.ansatz.circuit import Circuit
from paddle_quantum.qinfo import state_fidelity, partial_trace, purity
import warnings
from paddle_quantum.state import bell_state
if __name__ == '__main__':
  """Calculate Entanglement Capability"""
  backend_run = DynamicsBackend.from_backend(backend, evaluation_mode="sparse")
  solver_options = {"method": "jax_odeint", "atol": 1e-6, "rtol": 1e-8}

  backend_run.set_options(solver_options=solver_options,experiment_result_function=new_experiment_result_function)
  backend_run.configuration = lambda: backend.configuration()
  outputs_mix = list()   
  num_sample = 500
  ent_list = []
  amp_list = []
  ang_list = []
  duration_list = []

  for _ in range(num_sample):

    amp = [float(decimal.Decimal(random.randrange(0, 100))/100) for _ in range(10)]
    ang = [2*np.pi*float(decimal.Decimal(random.randrange(0, 100))/100) for _ in range(13)]
 #   ang = [0.8 for _ in range(7)]
    duration = [random.randrange(256, 1024, 16) for _ in range(3)]
    # generate new parametrized pulse
    firstlayer = block_pulsefixedamp(backend, amp, ang,duration)
    # set up pulse schedule
#    cirq_gates = assemble(firstlayer,
#                      backend=backend_sim,
#                      qubit_lo_freq=freq,
#                      meas_level=2,
#                      meas_return='avg',
#                      shots=2048)

    results = backend_run.run(firstlayer, meas_level = 2).result()
    # Returen the density matrix of q0
    vec = results.results[0].statevector
    # print(len(vec))
    rho1 = qi.partial_trace(vec, [1,2,3,4])
    rho2 = qi.partial_trace(vec, [0,2,3,4])
    rho3 = qi.partial_trace(vec, [0,1,2,4])
    rho4 = qi.partial_trace(vec, [0,1,2,3])
    p = (rho1.purity() + rho2.purity() + rho3.purity() + rho4.purity())/4
#    p = (qi.purity(rho1) + qi.purity(rho2))/2
#    p = (rho1.purity() + rho2.purity())/2
    # Calculate Q
    Q =2*(1-p)
    print(Q)
    ent_list.append(Q)
    ang_list.append(ang)
    amp_list.append(amp)
    duration_list.append(duration)

  import pickle
  file_open = open('Q.pickle','wb')
  pickle.dump(Q,file_open)
  file_open.close()

  Ent = sum(ent_list)/num_sample
  print("Eantangling Capability for this PQC is: {0:.6f}".format(Ent))

  file_open = open('4qfixedampdressedentlist.pickle','wb')
  pickle.dump(ent_list,file_open)
  file_open.close()
  file_open = open('4qfixedampdressedanglelist.pickle','wb')
  pickle.dump(ang_list,file_open)
  file_open.close()

  file_open = open('4qfixedampdressedamplitudelist.pickle','wb')
  pickle.dump(amp_list,file_open)
  file_open.close()
  file_open = open('4qfixedampdresseddurationlist.pickle','wb')
  pickle.dump(duration_list,file_open)
  file_open.close()
  """## 2.3 Scan angle"""







  """## 2.4 Scan both parameters"""

