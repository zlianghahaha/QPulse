# -*- coding: utf-8 -*-
"""MaxCut_QAOA.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Jg3flXCBX5Qzd21cSjPcChme10Uloxcw
"""
import argparse
import qiskit
import numpy as np
import mthree
import networkx as nx
from scipy.optimize import minimize
from qiskit import QuantumCircuit, execute, Aer, QuantumRegister,IBMQ
import matplotlib.pyplot as plt
from networkx.generators.random_graphs import erdos_renyi_graph
# 3-regular graph with six nodes 
from qiskit.transpiler import PassManager, CouplingMap
from qiskit.transpiler.passes import Collect2qBlocks
from qiskit.transpiler.passes import ConsolidateBlocks
from qiskit.transpiler.passes import Optimize1qGatesDecomposition
from qiskit.transpiler.passes.basis import BasisTranslator, UnrollCustomDefinitions
from qiskit.transpiler.passes.scheduling.calibration_creators import RZXCalibrationBuilderNoEcho
from qiskit.transpiler.passes.optimization.echo_rzx_weyl_decomposition import EchoRZXWeylDecomposition

from qiskit.circuit.library.standard_gates.equivalence_library import StandardEquivalenceLibrary as std_eqlib
from qiskit import IBMQ, transpile, Aer, pulse


def generate_pe_gate(qc, backend):
    inst_map = backend.defaults().instruction_schedule_map
    channel_map = backend.configuration().qubit_channel_mapping
    cmap = backend.configuration().coupling_map
    rzx_basis = ['rzx', 'rz', 'x', 'sx']
    red_map = CouplingMap(cmap).reduce(mapping=[0,1,2,3,4,5])
    #qc_transpiled = qc.decompose(rzx_basis)
    qc_transpiled = transpile(qc, backend=backend, coupling_map = red_map, initial_layout=[0,1,2,3,4,5], optimization_level=3, basis_gates=rzx_basis)
    pulse_efficient_gate = PassManager(
        [
            # Consolidate consecutive two-qubit operations
            Collect2qBlocks(),
            ConsolidateBlocks(basis_gates=['rz', 'sx', 'x', 'rxx']),
            # Rewrite circuit in terms of Cartan-decomposed echoed RZX gates
            EchoRZXWeylDecomposition(inst_map),
            # Calibrations for RZX gates
            RZXCalibrationBuilderNoEcho(inst_map, channel_map),
            # Rewrite in rzx basis
            UnrollCustomDefinitions(std_eqlib, rzx_basis),
            BasisTranslator(std_eqlib, rzx_basis),
            Optimize1qGatesDecomposition(rzx_basis)
        ]
    )
    qc_pe = pulse_efficient_gate.run(qc_transpiled)
    return qc_pe 

# Hamiltonian layer
def zz_term(qc, q1, q2, gamma):
    qc.cx(q1,q2)
    qc.rz(gamma, q2)
    qc.cx(q1,q2)

def get_cost_circuit(qc, G, gamma):
    N = G.number_of_nodes()
    for i, j in G.edges():
        zz_term(qc, i, j, gamma)
    return qc

# Mixer layer
def x_term(qc, q1, beta):
    qc.rx(beta, q1)

def get_mixer_circuit(qc, G, beta):
    N = G.number_of_nodes()
    for n in G.nodes():
        x_term(qc, n, beta)
    return qc

# Combine two layers and get the QAOA circuit
def get_qaoa_circuit(G, beta, gamma):
    p = len(beta) # infering number of QAOA steps from the parameters passed
    N = G.number_of_nodes()
    qc = QuantumCircuit(N,N)
    # get the initial state
    qc.h(range(N))
    # second, apply p alternating operators
    for i in range(p):
        qc = get_cost_circuit(qc,G,gamma[i])
        qc = get_mixer_circuit(qc,G,beta[i])
    # finally, do not forget to measure the result!
    qc.barrier(range(N))
    qc.measure(range(N), range(N))
    return qc

def measure_circuit(qc, n_trials=1024):
    """Get the output from circuit, either measured samples or full state vector"""
    job = execute(qc, backend, initial_layout = [0,1,2,3,4,5,6,7], shots=n_trials, optimization_level=3)
    mit = mthree.M3Mitigation(backend)
    mit.cals_from_system([0,1,2,3,4,5,6,7])
    result = job.result()
    counts = result.get_counts()
    quasis = mit.apply_correction(counts, [0,1,2,3,4,5,6,7])
    bitstrings = invert_counts(quasis)
    return bitstrings

# define the objective function
def invert_counts(counts):
    return {k[::-1]:v for k, v in counts.items()}

def maxcut_obj(x,G):
    ''' calculate energy from one bitstring '''
    cut = 0
    for i, j in G.edges():
        if x[i] != x[j]:
            # the edge is cut
            cut -= 1
    return cut

def compute_maxcut_energy(counts, G, cvar):
    ''' calculate energy from samples '''
    energy = 0
    energy1 = []
    total_counts = 0
    for meas, meas_count in counts.items():
        obj_for_meas = maxcut_obj(meas, G)
        meas_count = round(meas_count * 1000)
        energy1 += [obj_for_meas] * meas_count
        total_counts += meas_count  
      
    if cvar is None:
        energy = sum(energy1) / total_counts
    else:
        energy1.sort(reverse = False) 
        alpha_n = cvar*total_counts
        energy = sum(energy1[:int(alpha_n)])/alpha_n           
    return energy

def get_black_box_objective(G,p,cvar):
    def f(theta):
        # first half is betas, second half is gammas
        beta = theta[:p]
        gamma = theta[p:]
        ## define the qaoa circuit
        qc = get_qaoa_circuit(G,beta, gamma)
        counts = measure_circuit(qc, n_trials=1024)
        # return the energy
        return compute_maxcut_energy(counts, G, cvar)
    return f

def IBMQ_ini(backend_str):
    IBMQ.load_account()
    # provider = IBMQ.get_provider(hub="ibm-q-research", group="MIT-1", project="main")
    #provider = IBMQ.get_provider(hub='ibm-q-ornl', group='anl', project='csc428')
    provider = IBMQ.get_provider(hub='ibm-q-ncsu', group='nc-state', project='quantum-compiler')
    backend = provider.get_backend(backend_str)
    return backend

if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('--backend',  type=str,   default='ibmq_quito',help='name of the backend(not a simulator)')
    # parser.add_argument('--optimizer',type=str,   default='COBYLA',    help='name of the non-gradient optimizer')
    # parser.add_argument('--policy',   type=str,   default='cxrx',      help='name of the pulse growth policy')
    # parser.add_argument('--molecule', type=str,   default='H2',        help='name of the molecules')
    # parser.add_argument('--tune_freq',type=bool,  default=False,       help='specify if frequencies are tuned')
    # parser.add_argument('--n_iter',   type=int,   default=50,          help='number of training iterations')
    # parser.add_argument('--n_shot',   type=int,   default=1024,        help='number of shots for measurement')
    # parser.add_argument('--n_step',   type=int,   default=2,           help='number of pulse_layers')
    # parser.add_argument('--max_jobs', type=int,   default=15,          help='number of max_jobs for multiprocessing')
    # parser.add_argument('--rhobeg',   type=float, default=0.2 ,        help='rhobeg for non-gradient optimizer')

    args = parser.parse_args()
    backend_str = args.backend
    #G = erdos_renyi_graph(6, 0.5, 123)
    cvar = None
    G = nx.random_regular_graph(d=3, n=8, seed=12345)
    backend = IBMQ_ini(backend_str)
    p = 1
    obj = get_black_box_objective(G, p, cvar)
    init_point = np.random.rand(p*2)

    # Training the QAOA
    result = minimize(obj, init_point, method='COBYLA', options={'maxiter':50, 'disp': True})

    print(result.fun)
    print(result.x)
